{"posts":[{"title":"C++关键字","text":"C++类型转换关键字 const_cast:：把const属性去掉，即将const转换为非const（也可以反过来），const_cast只能用于指针或引用，并且只能改变对象的底层const（顶层const，本身是const，底层const，指向对象const）； static_cast:：隐式类型转换，可以实现C++中内置基本数据类型之间的相互转换，enum、struct、 int、char、float等，能进行类层次间的向上类型转换和向下类型转换（向下不安全，因为没有进行动态类型检查）。它不能进行无关类型(如非基类和子类)指针之间的转换，也不能作用包含底层const的对象； dynamic_cast：动态类型转换，用于将基类的指针或引用安全地转换成派生类的指针或引用（也可以向上转换），若指针转换失败返回NULL，若引用返回失败抛出bad_cast异常。dynamic_cast是在运行时进行安全性检查；使用dynamic_cast父类一定要有虚函数，否则编译不通过； reinterpret_cast：reinterpret是重新解释的意思，此标识符的意思即为将数据的二进制形式重新解释，但是不改变其值，有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用（比较不安全）。 static_cast和dynamic_cast的异同点？二者都会做类型安全检查，只是static_cast在编译期进行类型检查，dynamic_cast在运行期进行类型检查。后者需要父类具备虚函数，而前者不需要。","link":"/2025/06/06/C++%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"C++整体框架","text":"本框架基于Primer C++第五版进行构建，正在逐步施工中，会超链接到已经完成的文章。 C++基础 变量 字符串 表达式 语句 函数类 C++标准库 IO库 顺序容器 泛型算法 关联容器 动态内存 C++类设计者的工具 拷贝控制 重载运算与类型转换 OOP程序设计 模板与泛型 C++11新特性 lambda表达式 auto nullptr","link":"/2025/06/06/C++%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/"},{"title":"学习方法论","text":"建立知识体系的方法结构化时间线流程化&nbsp; Tips 学习步骤：3W：（What、Why、How） 多问为什么","link":"/2025/06/06/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"title":"C++中的虚函数","text":"C++中的多态 多态是面向对象编程的三大原则之一（封装、继承、多态）。 所谓多态，就是同一个函数名具有多种状态，或者说一个接口具有不同的行为。 C++的多态分为编译时多态和运行时多态. 编译时多态也称为为静态联编，通过重载和模板来实现；运行时多态称为动态联编，通过继承和虚函数来实现。 虚函数的实现机制 虚函数是通过虚函数表来实现的，虚函数表包含了一个类（所有）的虚函数的地址。 在有虚函数的类对象中，它内存空间的头部会有一个虚函数表指针（虚表指针），用来管理虚函数表。 当子类对象对父类虚函数进行重写的时候，虚函数表的相应虚函数地址会发生改变，改写成这个虚函数的地址，当我们用一个父类的指针来操作子类对象的时候，它可以指明实际所调用的函数。 虚函数的特质 虚函数存在于类中，不同的类对象共享一张虚函数表（为了节省内存空间）。 在C中实现虚函数 需要做的工作：手动构造父子关系、创建虚函数表、设置虚表指针并指向虚函数表、填充虚函数表；当虚函数重写的时候还需要手动修改函数指针等等。","link":"/2025/06/06/CPP%E9%87%8C%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0/"},{"title":"C++内存管理","text":"C++中的内存分区 堆，使用malloc、free动态分配和释放空间，能分配较大的内存； 栈，为函数的局部变量分配内存，能分配较小的内存； 全局/静态存储区，用于存储全局变量和静态变量； 常量存储区，专门用来存放常量； 自由存储区：通过new和delete分配和释放空间的内存，具体实现可能是堆或者内存池。 堆和自由存储区的区别：堆是C和操作系统的术语，自由存储区是C++的术语，指的是通过new和delete动态分配和释放对象的抽象概念；基本上C++也会用堆区实现自由存储，但程序员可以通过重载操作符，改用其他内存实现自由存储，比如全局变量做的对象池。 堆和栈的区别： 堆中的内存需要手动申请和手动释放，栈中内存是由OS自动申请和自动释放； 堆能分配的内存较大（4G(32位机器)），栈能分配的内存较小（1M）； 在堆中分配和释放内存会产生内存碎片，栈不会产生内存碎片； 堆的分配效率低，栈的分配效率高； 堆地址从低向上，栈由高向下。 内存泄漏（Memory Leak）是指程序在运行过程中分配了内存空间，但在不再使用这些内存时，没有释放它们，导致这部分内存无法被重新利用。长期下去，内存泄漏会导致程序占用越来越多的内存，甚至可能导致程序崩溃。 使用C/C++进行内存的分配、释放。C使用malloc/free，C++使用new/delete，前者是C语言中的库函数，后者是C++语言的运算符，对于自定义对象，malloc/free只进行分配内存和释放内存，无法调用其构造函数和析构函数，只有new/delete能做到，完成对象的空间分配和初始化，以及对象的销毁和释放空间，不能混用，具体区别如下： new分配内存空间无需指定分配内存大小，malloc需要； new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型； new是从自由存储区获得内存，malloc从堆中获取内存； 对于类对象，new会调用构造函数和析构函数，malloc不会（核心）。 内存对齐C++进行内存对齐的原因：关键在于CPU存取数据的效率问题。为了提高效率，计算机从内存中取数据是按照一个固定长度的。比如在32位机上，CPU每次都是取32bit数据的，也就是4字节；若不进行对齐，要取出两块地址中的数据，进行掩码和移位等操作，写入目标寄存器内存，效率很低。内存对齐一方面可以节省内存，一方面可以提升数据读取的速度。 关键在于CPU存取数据的效率问题。为了提高效率，计算机从内存中取数据是按照一个固定长度的。比如在32位机上，CPU每次都是取32bit数据的，也就是4字节；若不进行对齐，要取出两块地址中的数据，进行掩码和移位等操作，写入目标寄存器内存，效率很低。内存对齐一方面可以节省内存，一方面可以提升数据读取的速度。 C++对齐的原则 结构体变量的首地址能够被其最宽基本类型成员的对齐值所整除； 结构体内每一个成员的相对于起始地址的偏移量能够被该变量的大小整除； 结构体总体大小能够被最宽成员大小整除；如果不满足这些条件，编译器就会进行一个填充（padding）。 我们应该怎么做？声明数据结构时，字节对齐的数据依次声明，然后小成员组合在一起，能省去一些浪费的空间，不要把小成员参杂声明在字节对齐的数据之间。","link":"/2025/06/06/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"游戏客户端-网络","text":"Mirror和NetCode比较头疼的一点就是双端代码是写在一起的，一开始理解起来会很困难。 了解： OSI七层架构、TCP/IP五层架构。 &nbsp; UDP： 无连接，大小控制在64K里面，不可靠传输，由于不需要连接速度稍快 TCP： 面向字节流的可靠传输，需要三次握手/四次挥手来建立连接、断开连接，因此传输效率较慢。 &nbsp; Socket套接字： 是计算机之间进行通信的一系列协议。如果要进行网络开发，则要使用要Socket。本质是包含了TCP/IP的协议的API。","link":"/2025/06/06/%E6%B8%B8%E6%88%8F%E5%AE%A2%E6%88%B7%E7%AB%AF-%E7%BD%91%E7%BB%9C/"},{"title":"STL底层容器","text":"vector，底层是一块具有连续内存的数组，vector的核心在于其长度自动可变。vector的数据结构主要由三个迭代器(指针)来完成：指向首元素的start，指向尾元素的finish和指向内存末端的end_of_storage。vector的扩容机制是：当目前可用的空间不足时，分配目前空间的两倍或者目前空间加上所需的新空间大小（取较大值），容量的扩张必须经过“重新配置、元素移动、释放原空间”等过程。 list，底层是一个循环双向链表，链表结点和链表分开独立定义的，结点包含pre、next指针和data数据。 deque，双向队列，由分段连续空间构成，每段连续空间是一个缓冲区，由一个中控器来控制。它必须维护一个map指针（中控器指针），还要维护start和finish两个迭代器，指向第一个缓冲区，和最后一个缓冲区。deque可以在前端或后端进行扩容，这些指针和迭代器用来控制分段缓冲区之间的跳转。 stack和queue，栈和队列。它们都是由deque作为底层容器实现的，他们是一种容器配接器，修改了deque的接口，具有自己独特的性质（此二者也可以用list作为底层实现）；stack是deque封住了头端的开口，先进后出，queue是deque封住了尾端的开口，先进先出。 priority_queue，优先队列。是由以vector作为底层容器，以heap作为处理规则，heap的本质是一个完全二叉树。 set和map。底层都是由红黑树实现的。红黑树是一种二叉搜索树，但是它多了一个颜色的属性。红黑树的性质如下：1）每个结点非红即黑；2）根节点是黑的；3）如果一个结点是红色的，那么它的子节点就是黑色的；4）任一结点到树尾端（NULL）的路径上含有的黑色结点个数必须相同。通过以上定义的限制，红黑树确保没有一条路径会比其他路径多出两倍以上；因此，红黑树是一种弱平衡二叉树，相对于严格要求平衡的平衡二叉树来说，它的旋转次数少，所以对于插入、删除操作较多的情况下，通常使用红黑树。 补充：平衡二叉树（AVL）和红黑树的区别：AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance（旋转操作），导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。","link":"/2025/06/06/STL%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[],"pages":[]}