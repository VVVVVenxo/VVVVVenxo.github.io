---
title: C++中的虚函数
toc: true
categories:
  - 编程语言
  - C++
tags:
  - 面向对象
  - 多态
  - 虚函数
description: 深入理解 C++ 多态机制：虚函数的实现原理（虚函数表）、静态联编与动态联编的区别，以及在 C 语言中模拟虚函数的方法。
---

## C++ 中的多态

多态是面向对象编程的三大原则之一（封装、继承、多态）。

**多态的含义**：同一个函数名具有多种状态，或者说一个接口具有不同的行为。

### 多态的分类

| 类型 | 别名 | 实现方式 |
|------|------|----------|
| 编译时多态 | 静态联编 | 函数重载、模板 |
| 运行时多态 | 动态联编 | 继承 + 虚函数 |

---

## 虚函数的实现机制

虚函数是通过 **虚函数表 (vtable)** 来实现的。

### 虚函数表结构

```
┌─────────────────┐
│  Base 对象       │
├─────────────────┤
│  vptr ──────────┼──────► ┌─────────────────┐
├─────────────────┤        │ Base::vtable    │
│  成员变量        │        ├─────────────────┤
└─────────────────┘        │ &Base::func1    │
                           │ &Base::func2    │
                           └─────────────────┘

┌─────────────────┐
│  Derived 对象    │
├─────────────────┤
│  vptr ──────────┼──────► ┌─────────────────┐
├─────────────────┤        │ Derived::vtable │
│  成员变量        │        ├─────────────────┤
└─────────────────┘        │ &Derived::func1 │  ← 重写了
                           │ &Base::func2    │  ← 继承的
                           └─────────────────┘
```

### 工作原理

1. 含有虚函数的类，其对象内存头部会有一个 **虚表指针 (vptr)**
2. 虚表指针指向该类的 **虚函数表**，表中存放虚函数的地址
3. 子类重写父类虚函数时，虚函数表中对应的地址会被替换
4. 通过父类指针调用虚函数时，运行时会根据 vptr 找到正确的函数地址

```cpp
class Base {
public:
    virtual void speak() { cout << "Base" << endl; }
};

class Derived : public Base {
public:
    void speak() override { cout << "Derived" << endl; }
};

Base* p = new Derived();
p->speak();  // 输出 "Derived"（运行时多态）
```

---

## 虚函数的开销

使用虚函数会带来一定的性能开销：

| 开销类型 | 说明 |
|----------|------|
| **空间开销** | 每个含虚函数的对象需要额外存储一个 vptr（通常 8 字节） |
| **时间开销** | 调用虚函数需要通过 vptr 间接寻址，比普通函数调用多一次内存访问 |
| **内联失效** | 虚函数通常无法被内联优化 |

### 何时使用虚函数？

- 需要运行时多态时使用
- 性能敏感的热点代码中慎用（如游戏循环）
- 可考虑使用 CRTP（奇异递归模板模式）实现静态多态

---

## 虚函数的特性

- 同一个类的所有对象 **共享一张虚函数表**（节省内存）
- 虚函数表在 **编译期** 生成，存储在只读数据段
- 析构函数通常应声明为 `virtual`，避免基类指针删除派生类对象时内存泄漏

---

## 在 C 语言中模拟虚函数

C 语言没有虚函数机制，但可以手动模拟：

1. 定义函数指针结构体（虚函数表）
2. 在"对象"结构体中保存指向虚函数表的指针
3. 手动设置和调用函数指针

```c
// 虚函数表
typedef struct {
    void (*speak)(void* self);
} AnimalVTable;

// "类"定义
typedef struct {
    AnimalVTable* vtable;
    char name[32];
} Animal;

void dog_speak(void* self) {
    printf("Woof!\n");
}

AnimalVTable dog_vtable = { dog_speak };

void init_dog(Animal* a) {
    a->vtable = &dog_vtable;
}

// 使用
Animal dog;
init_dog(&dog);
dog.vtable->speak(&dog);  // 输出 "Woof!"
```