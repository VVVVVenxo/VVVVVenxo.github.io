---
title: 【数据结构】哈希表
toc: true
categories:
  - 技术笔记
  - 数据结构
cover: /img/covers/code_dark.jpg
date: 2025-06-05
tags:
  - 哈希表
  - 哈希冲突
  - 数据结构
description: 理解哈希表的工作原理、时间复杂度分析，以及哈希冲突的常见解决方法（拉链法、开放寻址法）。
---

## 什么是哈希表？

哈希表（Hash Table）是一种通过**哈希函数**将键（Key）映射到数组索引位置的数据结构，能够实现快速的查找、插入和删除操作。

### 基本结构

```
┌──────────────────────────────────────┐
│  Key  ──► Hash Function ──► Index   │
└──────────────────────────────────────┘

  "apple" ──► hash("apple") ──► 3
  "banana" ──► hash("banana") ──► 7
  "cherry" ──► hash("cherry") ──► 1

数组:
  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐
  │   │cherry│   │apple│   │   │   │banana│   │
  └───┴───┴───┴───┴───┴───┴───┴───┴───┘
    0   1   2   3   4   5   6   7   8
```

---

## 时间复杂度

| 操作 | 平均 | 最坏 |
|------|------|------|
| 查找 | O(1) | O(n) |
| 插入 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

**最坏情况**：当所有键都发生哈希冲突时，退化为链表。

---

## 哈希函数

好的哈希函数应该：
- 计算速度快
- 分布均匀，减少冲突
- 确定性：相同输入产生相同输出

### 常见哈希函数

```cpp
// 取模法
int hash(int key, int tableSize) {
    return key % tableSize;
}

// 字符串哈希
int hash(string key, int tableSize) {
    int hash = 0;
    for (char c : key) {
        hash = hash * 31 + c;
    }
    return hash % tableSize;
}
```

---

## 哈希冲突

当多个不同的键经过哈希函数计算后映射到**同一个位置**时，就发生了哈希冲突。

```
hash("apple") = 3
hash("grape") = 3   ← 冲突！
```

---

## 解决哈希冲突

### 方法一：拉链法（Separate Chaining）

每个数组位置存储一个链表，冲突的元素追加到链表中。

```
数组:
  ┌───┬───────────────┬───┬───┬───┐
  │ 0 │               │   │   │   │
  ├───┼───────────────┤   │   │   │
  │ 1 │ → [cat] → [dog]   │   │   │   ← 链表
  ├───┼───────────────┤   │   │   │
  │ 2 │               │   │   │   │
  ├───┼───────────────┤   │   │   │
  │ 3 │ → [apple] → [grape]   │   │   ← 冲突的键在同一链表
  └───┴───────────────┴───┴───┴───┘
```

**实现示例**：

```cpp
class HashTable {
    vector<list<pair<string, int>>> table;
    int size;
    
public:
    HashTable(int n) : table(n), size(n) {}
    
    int hash(const string& key) {
        int h = 0;
        for (char c : key) h = h * 31 + c;
        return h % size;
    }
    
    void insert(const string& key, int value) {
        int idx = hash(key);
        for (auto& p : table[idx]) {
            if (p.first == key) {
                p.second = value;  // 更新
                return;
            }
        }
        table[idx].push_back({key, value});  // 插入
    }
    
    int* get(const string& key) {
        int idx = hash(key);
        for (auto& p : table[idx]) {
            if (p.first == key) return &p.second;
        }
        return nullptr;  // 未找到
    }
};
```

**优点**：
- 实现简单
- 删除操作方便
- 适合冲突较多的场景

**缺点**：
- 需要额外的链表空间
- 缓存不友好

---

### 方法二：开放寻址法（Open Addressing）

所有元素都存储在数组中。发生冲突时，按照某种规则寻找下一个空位置。

#### 线性探测（Linear Probing）

冲突时依次检查下一个位置：`(hash + 1) % size`，`(hash + 2) % size`...

```
插入 "apple" → hash = 3 → 存入位置 3
插入 "grape" → hash = 3 → 位置 3 被占 → 检查位置 4 → 存入

数组:
  ┌───┬───┬───┬───────┬───────┬───┐
  │ 0 │ 1 │ 2 │ apple │ grape │ 5 │
  └───┴───┴───┴───────┴───────┴───┘
                 ↑       ↑
               原位置   探测后存入
```

#### 二次探测（Quadratic Probing）

使用平方序列：`(hash + 1²) % size`，`(hash + 2²) % size`...

可以减少**聚集**（Clustering）问题。

#### 双重哈希（Double Hashing）

使用第二个哈希函数决定探测步长：

```cpp
int probe(int key, int i, int size) {
    int h1 = hash1(key);
    int h2 = hash2(key);
    return (h1 + i * h2) % size;
}
```

---

## 拉链法 vs 开放寻址法

| 特性 | 拉链法 | 开放寻址法 |
|------|--------|------------|
| 空间利用 | 需要额外指针空间 | 全部在数组中 |
| 缓存性能 | 较差 | 较好 |
| 删除操作 | 简单 | 需要标记删除 |
| 装载因子 | 可以 > 1 | 必须 < 1 |
| 实现复杂度 | 简单 | 较复杂 |

---

## 装载因子（Load Factor）

装载因子 = 元素数量 / 数组大小

```
α = n / m
```

- **拉链法**：α 可以超过 1，但过大会导致链表过长
- **开放寻址法**：α 必须小于 1，通常保持在 0.7 以下

当装载因子过高时，需要进行**扩容（Rehashing）**：
1. 创建更大的新数组（通常 2 倍）
2. 重新计算所有元素的哈希值
3. 将元素插入新数组

---

## 实际应用

| 语言 | 哈希表实现 |
|------|------------|
| C++ | `std::unordered_map`, `std::unordered_set` |
| C# | `Dictionary<K,V>`, `HashSet<T>` |
| Java | `HashMap`, `HashSet` |
| Python | `dict`, `set` |

### C++ 示例

```cpp
#include <unordered_map>

std::unordered_map<std::string, int> scores;
scores["Alice"] = 95;
scores["Bob"] = 87;

if (scores.find("Alice") != scores.end()) {
    std::cout << scores["Alice"];  // O(1) 查找
}
```

### C# 示例

```csharp
Dictionary<string, int> scores = new Dictionary<string, int>();
scores["Alice"] = 95;
scores["Bob"] = 87;

if (scores.TryGetValue("Alice", out int score)) {
    Console.WriteLine(score);  // O(1) 查找
}
```
