---
title: 【项目实战】哈夫曼编码压缩系统
toc: true
categories:
  - 技术笔记
  - 项目实战
cover: /img/covers/code.jpg
date: 2025-06-05
tags:
  - 数据结构
  - 哈夫曼编码
  - 文件压缩
  - C++
description: 基于哈夫曼编码算法实现的文件压缩/解压工具，涵盖哈夫曼树构建、编码生成、位操作与文件格式设计。
---

## 项目概述

这是一个基于**哈夫曼编码**算法实现的文件压缩/解压工具，作为数据结构课程设计项目。

### 功能特性

| 功能 | 说明 |
|------|------|
| 文件压缩 | 使用哈夫曼编码对文本文件进行压缩 |
| 文件解压 | 将压缩文件还原为原始文本 |
| 文件比较 | 验证解压后的文件与原文件是否一致 |
| 压缩率显示 | 压缩完成后显示压缩率 |

### 项目结构

```
HuffmanCompression/
├── CMakeLists.txt          # CMake 构建配置
├── compressionDefine.h     # 头文件：数据结构和常量定义
├── main.cpp                # 程序入口和菜单交互
├── menu.cpp                # 菜单显示
├── Compression.cpp         # 压缩功能实现
├── Decompression.cpp       # 解压功能实现
└── Check.cpp               # 文件比较功能
```

---

## 核心数据结构

### 哈夫曼树节点

```cpp
typedef struct HTNode
{
    int weight;  // 权重（字符频率）
    int parent;  // 双亲节点索引
    int lchild;  // 左孩子索引
    int rchild;  // 右孩子索引
} HTNode, *HuffmanTree;
```

每个节点存储权重和三个索引（父节点、左右孩子），使用**数组**存储树结构而非指针链表，便于序列化存储到文件中。

### 哈夫曼编码

```cpp
typedef int** HuffmanCode;
```

二维数组，`HC[i]` 存储第 i 个字符的哈夫曼编码序列，以 `-1` 结尾。

---

## 算法原理

### 哈夫曼编码流程

```
┌─────────────────────────────────────────────────────────┐
│  1. 统计字符频率                                         │
│     遍历文件，统计每个字符出现的次数                      │
├─────────────────────────────────────────────────────────┤
│  2. 构建哈夫曼树                                         │
│     将每个字符作为叶子节点，权值为其频率                   │
│     每次选择权值最小的两个节点合并                        │
│     重复直到只剩一个根节点                                │
├─────────────────────────────────────────────────────────┤
│  3. 生成编码                                             │
│     从叶子节点向上回溯                                    │
│     左分支为 0，右分支为 1                                │
├─────────────────────────────────────────────────────────┤
│  4. 压缩数据                                             │
│     用编码替换原字符                                      │
│     每 8 位打包成 1 字节                                  │
└─────────────────────────────────────────────────────────┘
```

### 哈夫曼树构建

**核心思想**：贪心算法，每次选择频率最小的两个节点合并。

```cpp
// 构建哈夫曼树
for (i = n + 1; i <= m; ++i)
{
    Select(HT, i - 1, s1, s2);  // 选择两个最小节点
    HT[s1].parent = i;
    HT[s2].parent = i;
    HT[i].lchild = s1;
    HT[i].rchild = s2;
    HT[i].weight = HT[s1].weight + HT[s2].weight;
}
```

**Select 函数优化**：一次遍历同时找到两个最小权值节点，时间复杂度 O(n)。

```cpp
void Select(HuffmanTree HT, int n, int& s1, int& s2)
{
    int minWeight1 = INT_MAX, minWeight2 = INT_MAX;
    
    for (i = 1; i <= n; i++)
    {
        if (HT[i].parent != 0) continue;  // 跳过已有父节点的
        
        if (HT[i].weight < minWeight1)
        {
            minWeight2 = minWeight1;
            s2 = s1;
            minWeight1 = HT[i].weight;
            s1 = i;
        }
        else if (HT[i].weight < minWeight2)
        {
            minWeight2 = HT[i].weight;
            s2 = i;
        }
    }
}
```

### 编码生成

从叶子节点向根节点回溯，根据是左孩子还是右孩子生成 0 或 1：

```cpp
for (c = i, f = HT[i].parent; f != 0; c = f, f = HT[f].parent)
{
    if (HT[f].lchild == c)
        TempCode[--start] = 0;  // 左孩子：0
    else
        TempCode[--start] = 1;  // 右孩子：1
}
```

---

## 压缩文件格式

```
+-------------------+
| 字符种类数 (1B)   |
+-------------------+
| 编码位数位数 (1B) |
+-------------------+
| 编码总位数 (nB)   |  ← 按位存储
+-------------------+
| 哈夫曼树结构      |  ← 每节点 4 字节
| (weight, parent,  |
|  lchild, rchild)  |
+-------------------+
| ASCII 值映射表    |
+-------------------+
| 压缩后的数据      |
+-------------------+
```

### 头部信息

1. **字符种类数**：1 字节，表示文件中有多少种不同字符
2. **编码位数的位数**：1 字节，表示总位数需要多少位来存储
3. **编码总位数**：按位存储，用于解压时判断结束位置
4. **哈夫曼树结构**：完整存储树结构，便于解压时重建
5. **ASCII 映射表**：字符到索引的映射

---

## 位操作详解

### 压缩时的位打包

将哈夫曼编码（0/1 序列）打包成字节：

```cpp
pos = 0;
bitLength = 0;

for (codeIdx = 0; codeIdx <= k; codeIdx++)
{
    pos = pos * 2;                   // 左移一位
    pos = pos + HC[j + 1][codeIdx];  // 加入新的编码位
    bitLength++;
    
    if (bitLength == 8)              // 满 8 位
    {
        fwrite(&pos, sizeof(unsigned char), 1, fp);
        pos = 0;
        bitLength = 0;
    }
}

// 处理最后不足 8 位的情况
if (bitLength != 0)
{
    for (i = 1; i <= 8 - bitLength; i++)
        pos = pos * 2;  // 补 0
    fwrite(&pos, sizeof(unsigned char), 1, fp);
}
```

### 解压时的位解析

从字节中逐位提取：

```cpp
for (i = 0; i <= 7; i++)
{
    pos = ch;
    // 取出第 i 位
    for (k = 1; k <= i; k++)
        pos = pos * 2;   // 左移
    for (k = 1; k <= 7; k++)
        pos = pos / 2;   // 右移
    
    if (pos == 1)
        j = HT[j].rchild;  // 1：走右子树
    else
        j = HT[j].lchild;  // 0：走左子树
    
    // 到达叶子节点
    if ((HT[j].rchild == 0) && (HT[j].lchild == 0))
    {
        printf("%c", charAscii[j - 1]);
        j = 2 * charCount - 1;  // 重置到根节点
    }
}
```

---

## 性能优化

### O(1) 字符查找

使用索引数组替代线性查找：

```cpp
int charIndex[MAX_CHARS];  // ASCII 值到索引的映射

// 初始化
for (i = 0; i < MAX_CHARS; i++)
    charIndex[i] = -1;

// 添加字符时建立映射
charIndex[(unsigned char)ch] = i;

// 查找时 O(1)
int idx = charIndex[(unsigned char)ch];
```

**效果**：将字符查找从 O(n) 优化到 O(1)。

### 内存管理

正确释放所有动态分配的内存：

```cpp
// 释放哈夫曼编码数组
for (i = 1; i <= charCount; i++)
    free(HC[i]);
free(HC);

// 释放哈夫曼树
free(HT);
```

---

## 压缩率分析

```cpp
originalBits = totalChars * 8;           // 原始大小（位）
compressedBits = totalBits;              // 压缩后大小（位）
compressionRate = compressedBits / originalBits * 100;
```

**理论分析**：

- 高频字符获得短编码，低频字符获得长编码
- 平均编码长度接近信息熵
- 对英文文本通常可达 40%-60% 压缩率

---

## 使用示例

```
============================================
|      欢迎使用哈夫曼编码压缩系统          |
|                                          |
|  1. 压缩文件                             |
|  2. 解压文件                             |
|  3. 比较文件                             |
|  4. 退出                                 |
============================================

请输入要压缩的文件名：test.txt

字符 ASCII值 频率 哈夫曼编码
e      101    12    00
t      116    8     010
空格   32     7     011
...

压缩成功！已生成压缩文件yasuo.huf，压缩率为45.32%
```

---

## 技术要点总结

| 技术点 | 实现方式 |
|--------|----------|
| 哈夫曼树存储 | 数组存储，便于序列化 |
| 编码生成 | 从叶子回溯，避免递归开销 |
| 位打包 | 乘 2 / 除 2 替代位运算 |
| 字符查找 | 索引数组实现 O(1) 查找 |
| 文件格式 | 自定义头部 + 树结构 + 数据 |
| 内存管理 | 动态分配 + 正确释放 |

---

## 扩展方向

- **支持二进制文件**：当前仅支持文本文件
- **分块压缩**：支持大文件压缩
- **多线程压缩**：利用多核 CPU 加速
- **自适应编码**：动态调整编码表
- **添加校验码**：CRC/MD5 校验数据完整性
